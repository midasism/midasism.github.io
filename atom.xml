<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://midasism.github.io</id>
    <title>Gridea</title>
    <updated>2021-02-01T08:37:15.526Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://midasism.github.io"/>
    <link rel="self" href="https://midasism.github.io/atom.xml"/>
    <subtitle>凡事到最后必将皆大欢喜，如果没有，那就是还没到最后</subtitle>
    <logo>https://midasism.github.io/images/avatar.png</logo>
    <icon>https://midasism.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[AspectJ（转载）]]></title>
        <id>https://midasism.github.io/post/WML3zHU7p/</id>
        <link href="https://midasism.github.io/post/WML3zHU7p/">
        </link>
        <updated>2021-01-31T09:05:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844903924718108680">juejin.cn</a></p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1566806838&amp;ver=1813&amp;signature=Zo*EkhFh0D3t3XsaVkVRqTEs19G8thSMAEwqPp0Jxv*LUUvRKfkYNVCqBxKvWG3iP8wygi5wjrEII8IYkhZWXBnnwPp6JC34NWBjhM6*lm4BqqRkvl8YwWuvZw3rbJi*&amp;new=1">mp.weixin.qq.com/s?src=11&amp;ti…</a></p>
<p>前两天看了一些关于 spring aop 以及 AspectJ 的文章，但是总是感觉非常的乱，有的说 spring aop 跟 aspectj 相互独立，有的说 spring aop 依赖于 aspectj，有的甚至直接把两者混为一谈。很多专门讲 Aspectj 的文章也只是搬运了 AspectJ 的语法，就那么一两点东西，讲来讲去也没有什么新意。甚至很多甚至都是面向 IDE 编程 (教你怎么安装插件，点击菜单)，对 AspectJ 的使用方式和工作原理都不去分析，离开了 IDE 的支持甚至连编译都不会了。我认为咱们这些码农平时习惯用 IDE 并没有问题，但是不仅要做到会用 IDE，而且要做到超越 IDE，这样才能站到更高一点的视角看出工具的本来面目而不是受工具的局限。</p>
<p>当然，我吐槽了这么多其实并不是想标新立异，只是想找一个写文章的理由。虽然从某种方面讲，可能也算是” 茴香豆的 X 种写法 “，但是既然我自己乐在其中，那么开心就好喽。</p>
<p>为什么用 AspectJ，我的理解是两个字”方便 “。我们知道面向切面编程(Aspect Oriented Programming) 有诸多好处，但是在使用 AspectJ 之前我们一般是怎么编写切面的呢？我想一般来说应该是三种吧: 静态代理，jdk 动态代理，cglib 动态代理。但是我们知道，静态代理的重用性太差，一个代理不能同事代理多种类；动态代理可以做到代理的重用，但是即使这样，他们调用起来还是比较麻烦，除了写切面代码以外，我们还需要将代理类耦合进被代理类的调用阶段，在创建被代理类的时候都要先创建代理类，再用代理类去创建被代理类，这就稍微有点麻烦了。比如我们想在现有的某个项目里统一新加入一些切面，这时候就需要创建切面并且侵入原有代码，在创建对象的时候添加代理，还是挺麻烦的。</p>
<p>说到底，这种麻烦出现的本质原因是，代理模式并没有做到切面与业务代码的解耦。虽然将切面的逻辑独立进了代理类，但是决定是否使用切面的权利仍然在业务代码中。这才导致了上面这种麻烦。<br>
(当然，话不能说的这么绝对，如果有那种类似 Spring 的 IoC 容器，将类的创建都统一托管起来，我们只需要将切面用配置文件进行注册，容器会根据注册信息在创建 bean 的时候自动加上代理，这也是比较方便的。不过并不是所有框架都提供 IoC 机制的吧。。。)</p>
<p>既然代理模式这么麻烦，那么 AspectJ 又是通过什么方式来避免这个麻烦的呢？<br>
我总结 AspectJ 提供了两套强大的机制：</p>
<p>第一套是切面语法。就是网上到处都是的那种所谓”AspectJ 使用方法”，这套东西做到了将决定是否使用切面的权利还给了切面。在写切面的时候就可以决定哪些类的哪些方法会被代理，从而从逻辑上不需要侵入业务代码。由于这套语法实在是太有名，导致很多人都误以为 AspectJ 等于切面语法，其实不然。</p>
<p>第二套是织入工具。刚才讲到切面语法能够让切面从逻辑上与业务代码解耦，但是从操作上来讲，当 JVM 运行业务代码的时候，他甚至无从得知旁边还有个类想横插一刀。。。这个问题大概有两种解决思路，一种就是提供注册机制，通过额外的配置文件指明哪些类受到切面的影响，不过这还是需要干涉对象创建的过程；另外一种解决思路就是在编译期 (或者类加载期) 我们优先考虑一下切面代码，并将切面代码通过某种形式插入到业务代码中，这样业务代码不就知道自己被 “切” 了么？这种思路的一个实现就是 aspectjweaver，就是这里的织入工具。</p>
<p>一提起 AspectJ，其实我感觉绝大多数人都会联想到 Spring。毕竟，大多数人都是通过 spring 才接触到了 AspectJ。可事实上 Spring 只是用到了 AspectJ 的冰山一角，局限于 Spring 恐怕是不能很好的理解 AspectJ 的，因此这一节我讲不涉及任何 spring 的东西，单看下 AspectJ。<br>
事实上 AspectJ 提供了两套对切面的描述方法，一种就是我们常见的基于 java 注解切面描述的方法，这种方法兼容 java 语法，写起来十分方便，不需要 IDE 的额外语法检测支持；另外一种是基于 aspect 文件的切面描述方法，这种语法本身并不是 java 语法，因此写的时候需要 IDE 的插件支持才能进行语法检查。</p>
<h2 id="aspectj-相关-jar-包">AspectJ 相关 jar 包</h2>
<p>AspectJ 其实是 eclipse 基金会的一个项目，官网就在 eclipse 官网里。官网里提供了一个 aspectJ.jar 的下载链接，但其实这个链接只是一个安装包，把安装包里的东西解压后就是一个文档 + 脚本 + jar 包的程序包，其中比较重要的是如下部分：</p>
<pre><code>myths@pc:~/aspectj1.8$ tree bin/ lib/bin/├── aj├── aj5├── ajbrowser├── ajc└── ajdoclib/├── aspectjrt.jar├── aspectjtools.jar├── aspectjweaver.jar└── org.aspectj.matcher.jar复制代码
</code></pre>
<p>当然，这些 jar 包并不总是需要从官网下载，很多情况下在 maven 等中心库中直接找会更方便。<br>
这当中重点的文件是四个 jar 包中的前三个，bin 文件夹中的脚本其实都是调用这些 jar 包的命令。</p>
<ul>
<li>
<p>aspectjrt.jar 包主要是提供运行时的一些注解，静态方法等等东西，通常我们要使用 aspectJ 的时候都要使用这个包。</p>
</li>
<li>
<p>aspectjtools.jar 包主要是提供赫赫有名的 ajc 编译器，可以在编译期将将 java 文件或者 class 文件或者 aspect 文件定义的切面织入到业务代码中。通常这个东西会被封装进各种 IDE 插件或者自动化插件中。</p>
</li>
<li>
<p>aspectjweaverjar 包主要是提供了一个 java agent 用于在类加载期间织入切面 (Load time weaving)。并且提供了对切面语法的相关处理等基础方法，供 ajc 使用或者供第三方开发使用。这个包一般我们不需要显式引用，除非需要使用 LTW。</p>
</li>
</ul>
<p>上面的说明其实也就指出了 aspectJ 的几种标准的使用方法 (参考文档)：</p>
<ol>
<li>
<p>编译时织入，利用 ajc 编译器替代 javac 编译器，直接将源文件 (java 或者 aspect 文件) 编译成 class 文件并将切面织入进代码。</p>
</li>
<li>
<p>编译后织入，利用 ajc 编译器向 javac 编译期编译后的 class 文件或 jar 文件织入切面代码。</p>
</li>
<li>
<p>加载时织入，不使用 ajc 编译器，利用 aspectjweaver.jar 工具，使用 java agent 代理在类加载期将切面织入进代码。</p>
</li>
</ol>
<h2 id="基于-aspectj-文件的-aspectj">基于 aspectj 文件的 AspectJ</h2>
<p>这种说法比较蛋疼，其实我想说明的是这种不兼容 javac 的一种切面表示形式。比如当前我们有一个业务类 App.java:</p>
<pre><code>public class App {
    public void say() { 
        System.out.println(&quot;App say&quot;);
    } 
    public static void main(String[] args) {
            App app = new App();
            app.say(); 
    }
}
</code></pre>
<p>我们希望对在 say 函数里加一个切面, 那就创建一个 AjAspectj.aj 的文件:</p>
<pre><code>public aspect AjAspect{
        pointcut say():execution(*App.say(..));
        before():say(){
            System.out.println(&quot;AjAspect before say&quot;);
        }
        after():say(){
            System.out.println(&quot;AjAspect after say&quot;);
        }
}
</code></pre>
<p>这样我们就能实现切面的功能。可这个 aj 文件的语法虽然跟 java 很类似，但是毕竟还是不能用 javac 来编译，如果我们要用这个的话就必须使用 ajc 编译器。使用的方法大概有这几种:</p>
<ol>
<li>
<p>调用命令直接编译 (直接使用 ajc 命令或者调用 java -jar aspectjtools.jar)</p>
</li>
<li>
<p>使用 IDE 集成的 ajc 编译器编译</p>
</li>
<li>
<p>使用自动化构建工具的插件编译<br>
其实 2,3 两点的本质都是使用 aspectjtools.jar，最简单的调用方法如下:</p>
<pre><code>#!/usr/bin/env bashASPECTJ_TOOLS=/home/myths/.m2/repository/org/aspectj/aspectjtools/1.8.9/aspectjtools-1.8.9.jarASPECTJ_RT=/home/myths/.m2/repository/org/aspectj/aspectjrt/1.8.9/aspectjrt-1.8.9.jarjava -jar $ASPECTJ_TOOLS -cp $ASPECTJ_RT -sourceroots .
</code></pre>
</li>
</ol>
<p>调用 aspectjtools.jar 包，指定 aspectjrt 的 classpath，以及需要编译的路径，这样就会生成 AjAspectj.aj 以及 App.java 对应的 class 文件。我们反编译一下看看：<br>
AjAspectj.class:</p>
<pre><code>package com.aop;
import java.io.PrintStream;
import org.aspectj.lang.NoAspectBoundException;

public class AjAspect {
    private static Throwable ajc$initFailureCause;
    public static final AjAspect ajc$perSingletonInstance;

    public static AjAspect aspectOf() {
        if (ajc$perSingletonInstance == null) {
            throw new NoAspectBoundException(&quot;AjAspect&quot;, ajc$initFailureCause);
        }
        return ajc$perSingletonInstance;
    }

    public static boolean hasAspect() {
        return ajc$perSingletonInstance != null;
    }

    private static void ajc$postClinit() {
        ajc$perSingletonInstance = new AjAspect();
    }

    static {
        try {
        } catch (Throwable localThrowable) {
            ajc$initFailureCause = localThrowable;
        }
    }

    public void ajc$before$AjAspect$1$682722c() {
        System.out.println(&quot;AjAspect before say&quot;);
    }

    public void ajc$after$AjAspect$2$682722c() {
        System.out.println(&quot;AjAspect after say&quot;);
    }
}
</code></pre>
<p>App.class:</p>
<pre><code>import java.io.PrintStream;

public class App {
    public void say() {
        try {
            AjAspect.aspectOf().ajc$before$AjAspect$1$682722c();
            System.out.println(&quot;App say&quot;);
        } catch (Throwable localThrowable) {
            AjAspect.aspectOf().ajc$after$AjAspect$2$682722c();
            throw localThrowable;
        }
        AjAspect.aspectOf().ajc$after$AjAspect$2$682722c();
    }

    public static void main(String[] args) {
        App app = new App();
        app.say();
    }
}
</code></pre>
<p>调用 App.class，发现切面成功生效：</p>
<pre><code>$ java -cp ~/.m2/repository/org/aspectj/aspectjrt/1.8.9/aspectjrt-1.8.9.jar:.  AppAjAspect before sayApp sayAjAspect after say
</code></pre>
<p>我们发现 aj 文件的确被编译成了一个单例类，并且生成了一些切面方法，这些方法被织入进了 App 类中的 say 方法体中，可以说是非常的暴力了。(这里顺便吐槽一波 IntelliJ 自带的反编译器真的很烂，还是 jd-gui 好用)。</p>
<p>不过，虽然事实上这种基于 aj 文件的切面描述方法比基于 java 注解的切面描述方法用起来要灵活的多，但是由于他无法摆脱 ajc 的支持，而且本身不兼容 java 语法导致难以统一编码规范，加上需要较多额外的学习成本，因此事实上很多项目还是不怎么用这种方式，更多的还是采用了兼容 java 语法的用注解定义切面的方式。</p>
<h2 id="基于-java-注解的-aspectj">基于 java 注解的 AspectJ</h2>
<p>下面我们主要还是着力考虑下基于 java 注解的切面使用方法。</p>
<h3 id="准备">准备</h3>
<p>先建一个普通的项目看看，老样子，从 maven 的 maven-archetype-quickstart 开始，pom.xml，pom 文件里我们一般只需要加上 aspetjrt 的依赖即可。:</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;
    &lt;artifactId&gt;aspect-test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;name&gt;work&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
            &lt;version&gt;1.8.9&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.7.0&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>创建 App.java 文件:</p>
<pre><code>package com.aspect;

public class App {
    public void say() {
        System.out.println(&quot;App say&quot;);
    }

    public static void main(String[] args) {
        App app = new App();
        app.say();
    }
}
</code></pre>
<p>创建切面类 AnnoAspect.java:</p>
<pre><code>package com.mythsman.test;

import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspectpublic
class AnnoAspect {
    @Pointcut(&quot;execution(* com.mythsman.test.App.say(..))&quot;)
    public void jointPoint() {
    }

    @Before(&quot;jointPoint()&quot;)
    public void before() {
        System.out.println(&quot;AnnoAspect before say&quot;);
    }

    @After(&quot;jointPoint()&quot;)
    public void after() {
        System.out.println(&quot;AnnoAspect after say&quot;);
    }
}

</code></pre>
<p>当前项目结构应该是这样的：</p>
<pre><code>├── pom.xml
├── src
│   └── main
│       ├── java
│       │   └── com
│       │       └── mythsman
│       │           └── test
│       │               └── App.java
│       │               ├── AnnoAspect.java
</code></pre>
<p>其实就是创建了一个对 App 类进行切面的 AnnoAspect 类，这个类需要加上 @Aspect 注解用以声明这是一个切面，以及其他相关切面语法。接下来我们就来尝试下三种不同的编译方式。</p>
<h3 id="编译时织入">编译时织入</h3>
<p>编译时织入其实就是使用 ajc 来进行编译，暂时不使用自动化构建工具，我们先在项目根目录下手动写一个编译脚本 compile.sh:</p>
<pre><code>#!/usr/bin/env bashASPECTJ_WEAVER=/home/myths/.m2/repository/org/aspectj/aspectjweaver/1.8.13/aspectjweaver-1.8.13.jarASPECTJ_RT=/home/myths/.m2/repository/org/aspectj/aspectjrt/1.8.9/aspectjrt-1.8.9.jarASPECTJ_TOOLS=/home/myths/.m2/repository/org/aspectj/aspectjtools/1.8.9/aspectjtools-1.8.9.jarjava -jar $ASPECTJ_TOOLS -cp $ASPECTJ_RT -source 1.5 -sourceroots src/main/java/ -d target/classes
</code></pre>
<p>调用 aspectjtools.jar，在 - cp 里指明 aspectjrt.jar 的路径，-source 1.5 指明支持 java1.5 以后的注解，-sourceroots 指明编译的文件夹，-d 指明输出路径。</p>
<p>这样就会生成 AnnoAspect.class 和 App.class 两个文件。<br>
AnnoAspect.class:</p>
<pre><code>package com.mythsman.test;
import java.io.PrintStream;
import org.aspectj.lang.NoAspectBoundException;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspectpublic
class AnnoAspect {
    public static AnnoAspect aspectOf() {
        if (ajc$perSingletonInstance == null) {
            throw new NoAspectBoundException(&quot;com.mythsman.test.AnnoAspect&quot;, ajc$initFailureCause);
        }
        return ajc$perSingletonInstance;
    }

    public static boolean hasAspect() {
        return ajc$perSingletonInstance != null;
    }

    static {
        try {
            ajc$postClinit();
        } catch (Throwable localThrowable) {
            ajc$initFailureCause = localThrowable;
        }
    }

    @Before(&quot;jointPoint()&quot;)
    public void before() {
        System.out.println(&quot;AnnoAspect before say&quot;);
    }

    @After(&quot;jointPoint()&quot;)
    public void after() {
        System.out.println(&quot;AnnoAspect after say&quot;);
    }
}
</code></pre>
<p>App.class</p>
<pre><code>package com.mythsman.test;
import java.io.PrintStream;

public class App {
    public void say() {
        try {
            AnnoAspect.aspectOf().before();
            System.out.println(&quot;App say&quot;);
        } catch (Throwable localThrowable) {
            AnnoAspect.aspectOf().after();
            throw localThrowable;
        }
        AnnoAspect.aspectOf().after();
    }

    public static void main(String[] args) {
        App app = new App();
        app.say();
    }
}

</code></pre>
<p>我们发现 ajc 对 AnnoAspect 的处理方法与跟 AjAspect 的处理方法类似，都是将类声明成单例，并且识别 AspectJ 语法，将相关函数织入到 App 中。<br>
运行 (在项目根目录执行):</p>
<pre><code>$ java -cp ~/.m2/repository/org/aspectj/aspectjrt/1.8.9/aspectjrt-1.8.9.jar:src/main/java/ com.mythsman.test.App AnnoAspect before sayApp sayAnnoAspect after say
</code></pre>
<h3 id="编译后织入">编译后织入</h3>
<p>编译后织入其实就是在 javac 编译完成后，用 ajc 再去处理 class 文件得到新的、织入过切面的 class 文件。<br>
仍然是上面的项目，我们先用 javac 编译一下:</p>
<pre><code>$ javac -cp ~/.m2/repository/org/aspectj/aspectjrt/1.8.9/aspectjrt-1.8.9.jar  -d target/classes src/main/java/com/mythsman/test/*.java
</code></pre>
<p>编译成功后生成了 AnnoAspect.class 以及 App.class。显然，这两个 class 文件反编译后还是源文件的样子，并没有什么用，因此这时候执行 App 的 main 函数发现切面并没有生效。因此我们仍然需要用 ajc 来处理:</p>
<pre><code>!/usr/bin/env bashASPECTJ_WEAVER=/home/myths/.m2/repository/org/aspectj/aspectjweaver/1.8.13/aspectjweaver-1.8.13.jarASPECTJ_RT=/home/myths/.m2/repository/org/aspectj/aspectjrt/1.8.9/aspectjrt-1.8.9.jarASPECTJ_TOOLS=/home/myths/.m2/repository/org/aspectj/aspectjtools/1.8.9/aspectjtools-1.8.9.jarjava -jar $ASPECTJ_TOOLS -cp $ASPECTJ_RT -source 1.5 -inpath target/classes -d target/classes
</code></pre>
<p>这样就把 target/classes 中原来的 class 文件替换成了织入后的 class 文件。反编译之后发现与采用编译期织入方法的结果基本相同。</p>
<h3 id="加载时织入-ltw">加载时织入 (LTW)</h3>
<p>前两种织入方法都依赖于 ajc 的编译工具，LTW 却通过 java agent 机制在内存中操作类文件，可以不需要 ajc 的支持做到动态织入。<br>
不过，这里有一个挺有意思的问题，我们知道编译期一定会编译 AnnoAspect 类，那么这时候通过切面语法我们就可以找到他要处理的 App 类，这大概就是编译阶段织入的大概流程。但是如果在类加载期处理的话，当类加载到 App 类的时候，我们并不知道这个类需要被 AnnoAspect 处理。。。因此为了实现 LTW，我们肯定要有个配置文件，来告诉类加载器，某某某切面需要优先考虑，他们很可能会影响其他的类。<br>
为了实现 LTW，我们需要在资源目录下配置 META-INF/aop.xml 文件，来告知类加载器我们当前注册的切面。<br>
在上面的项目中，我们其实只需要创建 src/main/resources/META-INF/aop.xml：</p>
<pre><code>&lt;aspectj&gt;
    &lt;aspects&gt;
        &lt;aspect name=&quot;com.mythsman.test.AnnoAspect&quot;/&gt;
    &lt;/aspects&gt;
&lt;/aspectj&gt;
</code></pre>
<p>这样，我们就可以先使用 javac 编译源文件，再使用 java agent 在运行时织入:</p>
<pre><code>#!/usr/bin/env bashASPECTJ_WEAVER=/home/myths/.m2/repository/org/aspectj/aspectjweaver/1.8.13/aspectjweaver-1.8.13.jarASPECTJ_RT=/home/myths/.m2/repository/org/aspectj/aspectjrt/1.8.9/aspectjrt-1.8.9.jarASPECTJ_TOOLS=/home/myths/.m2/repository/org/aspectj/aspectjtools/1.8.9/aspectjtools-1.8.9.jarjava -javaagent:$ASPECTJ_WEAVER -cp $ASPECTJ_RT:target/classes/ com.mythsman.test.App
</code></pre>
<p>运行结果:</p>
<pre><code>AnnoAspect before sayApp sayAnnoAspect after say
</code></pre>
<p>当然，如果可以使用 ajc 的话，我们也可以通过 - outxml 参数来自动生成 xml 文件。</p>
<h3 id="maven-自动化构建">maven 自动化构建</h3>
<p>显然，自己写脚本还是比较麻烦的，如果用如 maven 这样的自动化构建工具的话就会方便很多，codehaus 提供了一个 ajc 的编译插件 aspectj-maven-plugin，我们只需要在 build/plugins 标签下加上这个插件的配置即可:</p>
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.10&lt;/version&gt;
    &lt;configuration&gt;
        &lt;source&gt;1.8&lt;/source&gt;
        &lt;target&gt;1.8&lt;/target&gt;
        &lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;compile&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>这个插件会绑定到编译期，采用的应该是编译后织入的方式，在 maven-compiler-plugin 处理完之后再工作的。<br>
不要以为这个插件多厉害，说白了他其实就是对 aspectjtools.jar 的一个 mojo 封装而已，去看他的依赖树就会很清楚。</p>
<p>这个问题很有意思，也是非常容易被搞混的，尤其是在讨论 spring aop 的时候。我们知道 spring 里有很多基于动态代理的设计，而我们知道动态代理也可以被用作面向切面的编程，但是 spring aop 本身却支持 aspectj 的切面语法，而且 spring-aop 这个包也引用了 aspectj，我们知道 aspectj 是通过织入的方式来实现 aop 的。。。那么 spring aop 究竟是通过织入还是代理来实现 aop 的呢？</p>
<h2 id="没错就是动态代理">没错就是动态代理</h2>
<p>其实 spring aop 还是通过动态代理来实现 aop 的，即使不去看他的源码，我们也可以通过简单的实验来得到这个结论。<br>
根据 aspectj 的使用方式，我们知道，如果要向代码中织入切面，那么我们要么采用 ajc 编译，要么使用 aspectjweaver 的 agent 代理。但是 spring 既没有依赖任何 aspectjtools 的相关 jar 包，虽然依赖了 aspectjweaver 这个包，但是并没有添加 agent 代理。当然，也存在一种可能就是 spring 利用 aspectjweaver 这个包自己实现了动态织入，但是从可复用的角度讲，spring 真的会自己重新造轮子？如果真的重新造了那为啥不脱离 aspectj 彻底重新造，而是用一半造一半呢？<br>
而且，我们知道用织入和用动态代理有一个很大的区别，如果使用织入的话，那么调业务对象的 getClass() 方法获得的类名就是这个类本身实现的类名；但是如果使用动态代理的话，调用 getClass() 方法获得的类名就是动态代理类的类名了。做一个简单的实验我们就可以发现，如果我们使用 spring aop 来对某一个 service 进行切面处理，那么调用 getClass() 方法获得的结果就是：</p>
<pre><code>com.mythsman.test.Myservice$$EnhancerBySpringCGLIB$$3afc9148
</code></pre>
<p>显然，虽然 spring aop 采用了 aspectj 语法来定义切面，但是在实现切面逻辑的时候还是采用 CGLIB 来进行动态代理的方法。</p>
<p>强行织入？</p>
<p>当然，如果我们想，我们也可以强行采用织入的方式，不过我们就不能将切面类注册为 spring 的 bean，并且采用 ajc 插件编译或者 java agent 在类加载时织入。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XML文件 配置AOP]]></title>
        <id>https://midasism.github.io/post/aop-xml/</id>
        <link href="https://midasism.github.io/post/aop-xml/">
        </link>
        <updated>2021-01-30T08:34:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-使用步骤">1、使用步骤</h2>
<h3 id="11-相关依赖">1.1、相关依赖</h3>
<p><strong>aspectjweaver</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</br>
<h3 id="12-编写切面方法">1.2、编写切面方法</h3>
<ul>
<li>切面方法参数中的JoinPoint对象为可选值<br>
</br></li>
<li><strong>前置通知</strong>和<strong>后置通知</strong><br>
无特殊要求<br>
</br></li>
<li><strong>返回后通知</strong><br>
| 获取目标方法返回值：切面方法增加一个参数，然后在配置文件中配置返回后通知的returning属性值为参数名</li>
</ul>
<pre><code class="language-java">//假设目标方法返回值类型为R
public void xx(JoinPoint joinPoint，R ret){}
</code></pre>
<pre><code class="language-xml">&lt;aop:after-returning method=&quot;xx&quot; pointcut-ref=&quot;&quot; returning=&quot;ret&quot;/&gt;
</code></pre>
</br>
<ul>
<li><strong>异常通知</strong><br>
| 获取异常信息：切面方法增加一个Throwable参数，然后在配置文件中配置异常通知的throwing属性值为Throwable参数名</br></li>
</ul>
<pre><code class="language-java">//切面方法
public void xx(JoinPoint joinPoint，Throwable th){}
</code></pre>
<pre><code class="language-xml">&lt;aop:after-throwing method=&quot;xx&quot; pointcut-ref=&quot;&quot; throwing=&quot;th&quot;/&gt;
</code></pre>
</br>
<ul>
<li><strong>环绕通知</strong><br>
| 切面方法使用proceed方法执行目标方法时必须抛出Throwable异常或者使用try-catch语句<br>
| <strong>如果切面方法没有将proceed方法的返回值返回，则最终目标方法实际执行时无返回值</strong><br>
|<strong>如果切面方法使用try-catch语句而没有抛出Throwable异常，则异常通知无法执行</strong></li>
</ul>
<pre><code class="language-java">//切面方法
    public Object xx(ProceedingJoinPoint joinPoint) {
        Object ret = null;
        //执行目标方法
        try {
            ...
            ret = joinPoint.proceed();
            ...
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return ret;
    }
</code></pre>
<pre><code class="language-xml">&lt;aop:around method=&quot;xx&quot; pointcut-ref=&quot;&quot;/&gt;
</code></pre>
</br>
<h3 id="13-xml配置文件">1.3、xml配置文件</h3>
<h4 id="131-创建切面类bean">1.3.1、创建切面类bean</h4>
<h4 id="132-配置aop-config">1.3.2、配置aop-config</h4>
<ol>
<li>配置aop:pointcut：决定切点的作用域<pre><code class="language-xml">     &lt;aop:pointcut id=&quot;&quot;  expression=&quot;execution(切点表达式)&quot;/&gt;
</code></pre>
</li>
<li>配置aop:aspect<pre><code class="language-xml">&lt;!-- method：选择切面类对应方法 --&gt;
&lt;!-- pointcut-ref：设置通知的作用域，选择上面配置过的pointcut --&gt;
     &lt;aop:aspect ref=&quot;切面类bean&quot;&gt;
         &lt;!-- 前置通知 before --&gt;
         &lt;aop:before method=&quot;&quot; pointcut-ref=&quot;上面配置的pointcut&quot;/&gt;
         &lt;!-- 返回后通知 after-returning --&gt;
         &lt;!-- returning：选择返回后通知对应的切面方法中的返回值参数名 --&gt;
         &lt;aop:after-returning method=&quot;&quot; pointcut-ref=&quot;&quot; returning=&quot;&quot;/&gt;

         &lt;!-- 异常通知 after-throwing --&gt;
         &lt;!-- throwing：选择异常通知对应的切面方法中的Throwable参数名 --&gt;
         &lt;aop:after-throwing method=&quot;&quot; pointcut-ref=&quot;&quot; throwing=&quot;&quot;/&gt;

         &lt;!-- 环绕通知 around --&gt;
         &lt;aop:around method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;

         &lt;!-- 后置通知 after --&gt;
         &lt;!-- 相当于try-catch语句中的finally块--&gt;
         &lt;aop:after method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;
     &lt;/aop:aspect&gt;
</code></pre>
</li>
</ol>
<p></br></br></br></p>
<h2 id="2-实战">2、实战</h2>
<h3 id="21-相关依赖">2.1、相关依赖</h3>
<p><strong>spring-context</strong>、<strong>aspectjweaver</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.12.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</br>
<h3 id="22-相关类">2.2、相关类</h3>
<p><strong>学生接口 StudentDao.java</strong></p>
<pre><code class="language-java">package com.dao;

public class StudentDao {
    public void insert(){ System.out.println(&quot;增加一个学生&quot;); }
}
</code></pre>
<p><strong>学生相关业务 StudentService.java</strong></p>
<pre><code class="language-java">package com.service;
import com.dao.StudentDao;

public class StudentService {
    private StudentDao studentDao;

    public StudentService() {}

    public StudentService(StudentDao studentDao) { this.studentDao = studentDao;  }

    public StudentDao getStudentDao() { return studentDao; }

    public void setStudentDao(StudentDao studentDao) {  this.studentDao = studentDao; }

    //业务一：添加学生
    public void createStudent(){
        System.out.println(&quot;学生入学&quot;);
        studentDao.insert();
    }

    //业务二：通过学号获取学生姓名
    public String getStudentName(String id) { return &quot;zhangsan&quot;; }
}
</code></pre>
<p><strong>切面方法类 MethodAspect.java</strong></p>
<pre><code class="language-java">package com.aspect;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class MethodAspect {
    //前置通知：获取执行时的时间
    public void currentTime(JoinPoint point) {
        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh-mm-ss&quot;);
        System.out.println(&quot;前置通知：&quot;+format.format(new Date()));
    }

    //后置通知：执行完毕后说再见
    public void afterSayBye(JoinPoint joinPoint) {
        System.out.println(&quot;后置通知：bye!&quot;);
    }

    //返回后通知：打印返回值
    public void printReturn(JoinPoint joinPoint, String ret) {
        System.out.println(&quot;返回值：&quot; + ret);
        Arrays.stream(joinPoint.getArgs()).forEach(e -&gt; System.out.println(&quot;参数：&quot; + e));
    }

    //异常通知：打印异常信息
    public void printError(JoinPoint joinPoint, Throwable th) {
        System.out.println(&quot;异常通知：&quot; + th.getMessage());
    }


    /**
     * 环绕通知：打印方法运行耗费的时间
     * 如果想要环绕通知和异常通知同时能工作，环绕通知需要抛出异常而不是使用try-catch语句
     */

     //抛出Throwable
    public Object printTotalRunningTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long beginTime = new Date().getTime();
        //执行目标方法
        Object ret = joinPoint.proceed();
        long endTime = new Date().getTime();
        System.out.println(&quot;环绕通知： &quot;+joinPoint.getSignature().getName() + &quot;方法所花的时间为：&quot; + (endTime - beginTime) + &quot;ms&quot;);
        return ret;
    }

//try-catch
    public Object printTotalRunningTime(ProceedingJoinPoint joinPoint) {
       Object ret = null;
       //执行目标方法
       try {
           long beginTime = new Date().getTime();
           ret = joinPoint.proceed();
           long endTime = new Date().getTime();
           System.out.println(joinPoint.getSignature().getName() + &quot;方法所花的时间为：&quot; + (endTime - beginTime) + &quot;ms&quot;);
       } catch (Throwable throwable) {
           throwable.printStackTrace();
       }
       return ret;
    }

}
</code></pre>
<p><strong>启动类 SpringApplication.java</strong></p>
<pre><code class="language-java">package com.aop;
import com.service.StudentService;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import java.util.Arrays;

public class SpringApplication {
    public static void main(String[] args) {
        AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        StudentService service = context.getBean(&quot;studentService&quot;, StudentService.class);
       String studentName = service.getStudentName(&quot;123456&quot;);
    }
}
</code></pre>
</br>
<h3 id="23-xml配置文件">2.3、xml配置文件</h3>
<p><strong>applicationContext.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;bean id=&quot;studentDao&quot; class=&quot;com.dao.StudentDao&quot;/&gt;
    &lt;bean id=&quot;studentService&quot; class=&quot;com.service.StudentService&quot;&gt;
        &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.aspect.MethodAspect&quot;/&gt;
    &lt;aop:config&gt;
        &lt;!--        配置切点的作用域--&gt;
        &lt;!--  多个条件使用 and或者or      --&gt;
        &lt;!--  expression=&quot;execution(public * com.service..*.*(..)) or execution(public * com.dao..*.*(..))&quot;--&gt;
        &lt;aop:pointcut id=&quot;service&quot;
                      expression=&quot;execution(public * com.service..*.*(..))&quot;/&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt;
            &lt;aop:before method=&quot;currentTime&quot; pointcut-ref=&quot;service&quot;/&gt;
            &lt;aop:after-returning method=&quot;printReturn&quot; pointcut-ref=&quot;service&quot; returning=&quot;ret&quot;/&gt;
            &lt;aop:after-throwing method=&quot;printError&quot; pointcut-ref=&quot;service&quot; throwing=&quot;th&quot;/&gt;
            &lt;aop:around method=&quot;printTotalRunningTime&quot; pointcut-ref=&quot;service&quot;/&gt;
            &lt;!--            相当于try-catch语句中的finally块--&gt;
            &lt;aop:after method=&quot;afterSayBye&quot; pointcut-ref=&quot;service&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
</br>
<h3 id="24-运行结果">2.4、运行结果</h3>
<figure data-type="image" tabindex="1"><img src="https://midasism.github.io/post-images/1612149890444.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Test与JUnit4整合]]></title>
        <id>https://midasism.github.io/post/dai-wan-cheng-spring-yu-junit4-zheng-he/</id>
        <link href="https://midasism.github.io/post/dai-wan-cheng-spring-yu-junit4-zheng-he/">
        </link>
        <updated>2021-01-29T05:46:01.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Spring Test是Spring中用于测试的模块</li>
<li>Spring Test对JUnit单元测试框架有良好的整合</li>
<li>通过Spring Test可以在JUnit单元测试时自动初始化IOC容器</li>
</ul>
<h2 id="1-环境准备">1、环境准备</h2>
<h3 id="11-相关依赖">1.1、相关依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.12.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--        Spring Test--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--        Junit--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="12-相关注解">1.2、相关注解</h3>
<ol>
<li>@RunWith(SpringJUnit4ClassRunner.class)：使Spring接管JUnit的控制权，在测试用例执行前自动初始化IOC容器</li>
<li>@ContextConfiguration(locations = {})：说明要加载的xml配置文件的位置（可加载多个配置文件）</li>
</ol>
<h2 id="2-实战">2、实战</h2>
<pre><code class="language-java">//Test.java
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import spring.service.StudentService;
import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:applicationContext.xml&quot;})
public class Test {
    @Resource
    private StudentService service;

    @org.junit.Test
    public void testService() {
        service.test();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Config 配置IOC容器]]></title>
        <id>https://midasism.github.io/post/dai-wan-cheng-java-config/</id>
        <link href="https://midasism.github.io/post/dai-wan-cheng-java-config/">
        </link>
        <updated>2021-01-28T10:36:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-概述">1、概述</h2>
<h3 id="11-由来">1.1、由来</h3>
<p>Spring IOC中有个重要的概念——Bean，Bean即对象，我们通过配置Bean让IOC容器管理Bean，而最常用的方式就是通过XML文件来配置，但通过XML文件来配置比较繁琐，数量较多的时候会使项目变得复杂，而且使用XML配置没有编译时的类型安全检查</p>
<p>所以在Spring4以后，Spring推荐使用Java Config代替XML文件来配置Bean</p>
<p>Java Config就是使用注解，通过java类来描述Bean配置的组件</p>
<p>Java Config结合了XML的解耦和JAVA编译时检查的优点，可以看成是一个XML文件，只不过是由Java编写的</p>
<h3 id="12-优缺点">1.2、优缺点</h3>
<h4 id="121-优点">1.2.1、优点</h4>
<ol>
<li>摒弃xml配置文件，使用Java类管理对象和依赖</li>
<li>注解配置相对分散，使用Java Config可以集中管理配置</li>
<li>可以在编译时进行依赖检查，不容易出错</li>
</ol>
<h4 id="122-缺点">1.2.2、缺点</h4>
<p>与xml配置文件相比，可维护性差</p>
<p></br></br></p>
<h2 id="2-相关注解">2、相关注解</h2>
<ol>
<li>@Configuration：描述类，用于标记Java Config配置类</li>
<li>@Bean：描述方法，IOC容器会管理被标记方法返回的对象（bean id默认为方法名）</li>
<li>@ComponentScan：描述类，扫描指定类中的注解配置（作用与xml配置中的<a href="context:component-scan">context:component-scan</a>标签相同）</li>
<li>@ImportResource：描述类，加载静态文件，可使用@Value注解获取</li>
</ol>
<p>| 由于是Java类的形式，所以同样可以使用各种类注解，比如@Primary</p>
<p></br></br></p>
<h2 id="3-使用步骤">3、使用步骤</h2>
<h3 id="31-创建配置类">3.1、创建配置类</h3>
<ul>
<li>需要使用 <strong>@Configuration</strong> 注解标注配置类</li>
</ul>
<pre><code class="language-java">//JavaConfig.java
package spring.config;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JavaConfig {

}
</code></pre>
<h3 id="32-创建bean">3.2、创建bean</h3>
<p>StudentController类</p>
<pre><code class="language-java">//StudentController.java
package spring.controller;
import lombok.Data;
import spring.service.StudentService;

@Data
public class StudentController {
    private StudentService service;

    public StudentController() {
        System.out.println(&quot;StudentController创建&quot;);
    }
}
</code></pre>
<p>StudentService类</p>
<pre><code class="language-java">//StudentService.java
package spring.service;

public class StudentService {
    public StudentService() {
        System.out.println(&quot;StudentService创建&quot;);
    }
}

</code></pre>
<h4 id="创建bean">创建bean</h4>
<ul>
<li>使用@Bean注解标注方法，IOC容器管理方法返回的对象（与XML配置中的<bean>标签作用相同）</li>
<li>bean id为方法名</li>
</ul>
<pre><code class="language-java">//JavaConfig.java
package spring;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import spring.controller.StudentController;
import spring.service.StudentService;

@Configuration
public class JavaConfig {
    //此处创建service、controller两个bean
    @Bean
    public StudentService service() {
        StudentService service = new StudentService();
        return service;
    }

    @Bean
    public StudentController controller() {
        StudentController controller = new StudentController();
        return controller;
    }
}
</code></pre>
<h4 id="测试">测试</h4>
<p>测试类</p>
<pre><code class="language-java">//ApplicationContext.java
package spring;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.AbstractApplicationContext;
import spring.config.JavaConfig;
import spring.controller.StudentController;
import java.util.Arrays;

public class ApplicationContext {
    public static void main(String[] args) {
        AbstractApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class);
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        Arrays.stream(beanDefinitionNames).forEach(e -&gt; System.out.println(e));
    }
}
</code></pre>
<p>测试结果<br>
| 打印IOC容器中所有的bean<br>
<img src="https://cdn.jsdelivr.net/gh/midasism/cloud-img@main/img/JavaConfig.png" alt="" loading="lazy"><br>
观察到两个bean创建成功</p>
<h3 id="33-设置对象依赖">3.3、设置对象依赖</h3>
<ul>
<li>设置对象依赖时，将依赖的对象通过方法的属性传入，并在方法中通过构造方法、setter等方式注入依赖</li>
<li><strong>在查找属性对应的bean时，先按属性名查找，找不到再按属性类型查找</strong></li>
</ul>
<pre><code class="language-java">//JavaConfig.java
......
    @Bean
    public StudentController controller(StudentService service) {
        StudentController controller = new StudentController();
        controller.setService(service);
        return controller;
    }
</code></pre>
<h4 id="测试-2">测试</h4>
<p>测试结果<br>
| 打印controller<br>
<img src="https://cdn.jsdelivr.net/gh/midasism/cloud-img@main/img/JavaConfig-02.png" alt="" loading="lazy"><br>
观察到属性注入成功</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于注解配置Bean]]></title>
        <id>https://midasism.github.io/post/ji-yu-zhu-jie-chu-shi-hua-ioc-rong-qi/</id>
        <link href="https://midasism.github.io/post/ji-yu-zhu-jie-chu-shi-hua-ioc-rong-qi/">
        </link>
        <updated>2021-01-27T08:52:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-环境准备">一、环境准备</h3>
<p>Spring配置文件 <strong>applicationContext.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;!-- 开启自动扫描 --&gt;
    &lt;context:component-scan base-package=&quot;待扫描的包&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="二-相关注解">二、相关注解</h3>
<ol>
<li>@Repository：标记数据访问层（dao）</li>
<li>@Controller：标记控制器层（controller）</li>
<li>@Service：标记业务层（service）</li>
<li>@Component：标记通用组件</li>
</ol>
<h4 id="要点">要点</h4>
<ul>
<li>如果使用默认注解，则类对应的bean的id为开头字母小写的类名</li>
<li>如果想要自定义bean的id，则对注解的value属性赋值即可</li>
</ul>
<pre><code class="language-java">//无参 bean id为student
@Controller()
public class Student {
    private String name;
    private String id;
}

//bean id为 s1
//@Controller(&quot;s1&quot;)
@Controller(value = &quot;s1&quot;)
public class Student {
    private String name;
    private String id;
}
</code></pre>
<ul>
<li>在类上使用以上四个注解后，Spring会自动创建相应的BeanDefinition对象，并注册到ApplicationContext中</li>
<li>可以创建自定义注解，然后在注解上标注@Component，该自定义注解就具有了@Component的功能</li>
<li>以上4个注解功能相同，只是作用位置不同，增强可读性</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现一个极简IOC容器]]></title>
        <id>https://midasism.github.io/post/ioc-demo/</id>
        <link href="https://midasism.github.io/post/ioc-demo/">
        </link>
        <updated>2021-01-27T02:03:34.000Z</updated>
        <content type="html"><![CDATA[<p>| 本文通过xml解析技术和反射技术手动实现Spring ioc容器通过xml配置文件初始化bean的过程，仅实现getBean方法</p>
<h3 id="1-环境准备">1、环境准备</h3>
<p>1、创建一个maven项目<br>
2、pom.xml中引入<strong>dom4j</strong>、<strong>jaxen</strong>、lombok依赖</p>
<p><strong>dom4j： xml解析组件</strong><br>
<strong>jaxen：Xpath表达式解析器</strong><br>
lombok：用于简化代码 比如setter、getter、构造器等等</p>
<pre><code class="language-xml">&lt;!--dom4j--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;dom4j&lt;/groupId&gt;
    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- jaxen--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jaxen&lt;/groupId&gt;
    &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- lombok--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="2-实现过程">2、实现过程</h3>
<p>1、实体类：Student<br>
| 此处在setter方法中打印语句，便于观察最终结果来印证ioc容器注入属性的方式</p>
<pre><code class="language-java">package com.ioc.entity;
import lombok.*;
@Getter
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Student {
    private String name;
    private String id;
    private String sex;

    public void setName(String name) {
        System.out.println(&quot;IOC容器通过setter方法注入name属性：&quot; + name);
        this.name = name;
    }

    public void setId(String id) {
        System.out.println(&quot;IOC容器通过setter方法注入id属性：&quot; + id);
        this.id = id;
    }

    public void setSex(String sex) {
        System.out.println(&quot;IOC容器通过setter方法注入sex属性：&quot; + sex);
        this.sex = sex;
    }
}
</code></pre>
<p>2、xml配置文件：applicationContext.xml<br>
| 配置文件结构和spring保持一致</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans&gt;
    &lt;bean id=&quot;s1&quot; class=&quot;com.ioc.entity.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;1928722031&quot;/&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3、ApplicationContext抽象类</p>
<pre><code class="language-java">public interface ApplicationContext {
    public Object getBean(String beanId);
}
</code></pre>
<p>4、<strong>ClassPathXmlApplicationContext</strong>：Spring context实现类</p>
<pre><code class="language-java">package com.ioc.context;
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;
import java.io.File;
import java.lang.reflect.Method;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext {
    //使用Map集合
    Map&lt;String, Object&gt; iocContainer = new HashMap&lt;&gt;();

    public ClassPathXmlApplicationContext() {
        try {
            //获取配置文件的路径
            String filepath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath();
            //将路径用UTF-8解码，防止中文路径乱码
            filepath = new URLDecoder().decode(filepath, &quot;UTF-8&quot;);
            //用于解析XML文件
            SAXReader reader = new SAXReader();
            //将xml文件解析成对象 便于操作
            Document document = reader.read(new File(filepath));
            //使用Xpath表达式选择所有bean元素 每个bean元素对应一个对象
            List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;);
            for (Node e : beans) {
                //将bean节点强制转化为Element 很关键
                Element element = (Element) e;
                //获取bean标签的属性值：id class
                String id = element.attributeValue(&quot;id&quot;);
                String eClass = element.attributeValue(&quot;class&quot;);
                //获取class属性代表的类的Class对象
                Class c = Class.forName(eClass);
                //利用反射 通过空构造器实例化bean
                //注：Class对象.newInstance()已被废弃
                Object o = c.getDeclaredConstructor().newInstance();
                //使用Xpath表达式选择bean元素的所有属性值 property节点
                //每个property节点代表对象的一个属性
                List&lt;Node&gt; propertys = element.selectNodes(&quot;property&quot;);
                for (Node p : propertys) {
                    Element property = (Element) p;
                    //获取property标签的属性值：name value
                    String name = property.attributeValue(&quot;name&quot;);
                    String value = property.attributeValue(&quot;value&quot;);
                    //此处采用字符串拼接构建属性对应的setter方法名
                    String setMethodName = &quot;set&quot; + name.substring(0, 1).toUpperCase() + name.substring(1);
                    //通过方法名和Class对象得到对应的Method类 便于后续反射调用
                    Method method = c.getMethod(setMethodName, String.class);
                    //通过反射 利用属性的setter方法对属性赋值
                    method.invoke(o, value);
                }
                //将创建好的bean放入IOC容器（Map）中
                iocContainer.put(id, o);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(&quot;ioc容器已初始化&quot;);
    }

    @Override
    public Object getBean(String beanId) {
        return iocContainer.get(beanId);
    }
}
</code></pre>
<p>5、测试类：Application</p>
<pre><code class="language-java">package com.ioc.context;
import com.ioc.entity.Student;
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Student s1 = (Student) context.getBean(&quot;s1&quot;);
        System.out.println(s1);
    }
}
</code></pre>
<p>运行结果：<br>
<img src="https://cdn.jsdelivr.net/gh/midasism/cloud-img@main/img/Gridea-ioc-01.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue使用指南]]></title>
        <id>https://midasism.github.io/post/vue-an-zhuang-yu-pei-zhi/</id>
        <link href="https://midasism.github.io/post/vue-an-zhuang-yu-pei-zhi/">
        </link>
        <updated>2020-11-29T07:05:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-安装并配置nodejs">一. 安装并配置node.js</h1>
<h2 id="1-安装">1. 安装</h2>
<h3 id="常规安装">常规安装</h3>
<p>nodejs官网下载：https://nodejs.org/zh-cn/#home-downloadhead</p>
<h3 id="scoop">scoop</h3>
<pre><code>    scoop install nodejs
</code></pre>
<ul>
<li>测试安装：命令行中输入以下命令，如果输出相应版本号，则安装成功</li>
</ul>
<pre><code>node -v
npm -v
</code></pre>
<h2 id="2-环境配置">2. 环境配置</h2>
<h3 id="1配置npm安装的全局模块的存放目录和缓存cache的路径">（1）配置npm安装的全局模块的存放目录和缓存cache的路径</h3>
<ol>
<li>在nodejs安装的根路径下创建<mark>node_cache</mark>和<mark>node_global</mark>文件夹</li>
<li>通过命令将自定义文件夹设置为nodejs全局模块存放目录和缓存cache路径</li>
</ol>
<pre><code>npm config set prefix &quot;node_global磁盘全路径&quot;
npm config set cache &quot;node_cachel磁盘全路径&quot;
</code></pre>
<ol start="3">
<li>添加环境变量</li>
</ol>
<ul>
<li>修改用户变量Path：添加 node_global 文件夹磁盘全路径</li>
<li>新建系统变量NODE_PATH：值为 node_global 文件夹中的 node_modules 文件夹的磁盘全路径</li>
</ul>
<h3 id="2npm换源">（2）npm换源</h3>
<p>更换淘宝镜像</p>
<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>查看npm配置信息，包括prefix、cache路径和npm源等等</p>
<pre><code>npm config list
</code></pre>
<h1 id="二-安装vue及相关模块">二. 安装vue及相关模块</h1>
<h3 id="vue">vue</h3>
<pre><code>npm install vue -g
</code></pre>
<h3 id="webpack">webpack</h3>
<pre><code>npm install webpack -g
</code></pre>
<h3 id="vue-脚手架-vue-cli">vue 脚手架 vue-cli</h3>
<pre><code>npm install vue-cli -g
</code></pre>
<h1 id="三-创建vue项目">三. 创建vue项目</h1>
<h2 id="新建项目存放目录在终端中进入该目录">新建项目存放目录，在终端中进入该目录</h2>
<pre><code>cd 目录全路径
</code></pre>
<h2 id="创建vue项目并在终端中进入">创建vue项目，并在终端中进入</h2>
<pre><code>vue init webpack 项目名
cd 项目名
</code></pre>
<h2 id="安装项目依赖">安装项目依赖</h2>
<h3 id="安装vue-路由模块-vue-router-和网络请求模块-vue-resource">安装vue 路由模块 vue-router 和网络请求模块 vue-resource</h3>
<pre><code>npm install vue-router vue-resource --save
</code></pre>
<h2 id="启动项目">启动项目</h2>
<pre><code>npm run dev
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://midasism.github.io/post/hello-gridea/</id>
        <link href="https://midasism.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>