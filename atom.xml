<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://midasism.github.io</id>
    <title>Gridea</title>
    <updated>2021-01-30T10:45:13.417Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://midasism.github.io"/>
    <link rel="self" href="https://midasism.github.io/atom.xml"/>
    <subtitle>凡事到最后必将皆大欢喜，如果没有，那就是还没到最后</subtitle>
    <logo>https://midasism.github.io/images/avatar.png</logo>
    <icon>https://midasism.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Spring Test与JUnit4整合]]></title>
        <id>https://midasism.github.io/post/dai-wan-cheng-spring-yu-junit4-zheng-he/</id>
        <link href="https://midasism.github.io/post/dai-wan-cheng-spring-yu-junit4-zheng-he/">
        </link>
        <updated>2021-01-29T05:46:01.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Spring Test是Spring中用于测试的模块</li>
<li>Spring Test对JUnit单元测试框架有良好的整合</li>
<li>通过Spring Test可以在JUnit单元测试时自动初始化IOC容器</li>
</ul>
<h2 id="1-环境准备">1、环境准备</h2>
<h3 id="11-相关依赖">1.1、相关依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.12.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--        Spring Test--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--        Junit--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="12-相关注解">1.2、相关注解</h3>
<ol>
<li>@RunWith(SpringJUnit4ClassRunner.class)：使Spring接管JUnit的控制权，在测试用例执行前自动初始化IOC容器</li>
<li>@ContextConfiguration(locations = {})：说明要加载的xml配置文件的位置（可加载多个配置文件）</li>
</ol>
<h2 id="2-实战">2、实战</h2>
<pre><code class="language-java">//Test.java
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import spring.service.StudentService;
import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:applicationContext.xml&quot;})
public class Test {
    @Resource
    private StudentService service;

    @org.junit.Test
    public void testService() {
        service.test();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java Config 配置Bean]]></title>
        <id>https://midasism.github.io/post/dai-wan-cheng-java-config/</id>
        <link href="https://midasism.github.io/post/dai-wan-cheng-java-config/">
        </link>
        <updated>2021-01-28T10:36:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-概述">1、概述</h2>
<h3 id="11-由来">1.1、由来</h3>
<p>Spring IOC中有个重要的概念——Bean，Bean即对象，我们通过配置Bean让IOC容器管理Bean，而最常用的方式就是通过XML文件来配置，但通过XML文件来配置比较繁琐，数量较多的时候会使项目变得复杂，而且使用XML配置没有编译时的类型安全检查</p>
<p>所以在Spring4以后，Spring推荐使用Java Config代替XML文件来配置Bean</p>
<p>Java Config就是使用注解，通过java类来描述Bean配置的组件</p>
<p>Java Config结合了XML的解耦和JAVA编译时检查的优点，可以看成是一个XML文件，只不过是由Java编写的</p>
<h3 id="12-优缺点">1.2、优缺点</h3>
<h4 id="121-优点">1.2.1、优点</h4>
<ol>
<li>摒弃xml配置文件，使用Java类管理对象和依赖</li>
<li>注解配置相对分散，使用Java Config可以集中管理配置</li>
<li>可以在编译时进行依赖检查，不容易出错</li>
</ol>
<h4 id="122-缺点">1.2.2、缺点</h4>
<p>与xml配置文件相比，可维护性差</p>
<h2 id="2-相关注解">2、相关注解</h2>
<ol>
<li>@Configuration：描述类，用于标记Java Config配置类</li>
<li>@Bean：描述方法，IOC容器会管理被标记方法返回的对象（bean id默认为方法名）</li>
<li>@ComponentScan：描述类，扫描指定类中的注解配置（作用与xml配置中的<a href="context:component-scan">context:component-scan</a>标签相同）</li>
<li>@ImportResource：描述类，加载静态文件，可使用@Value注解获取</li>
</ol>
<p>| 由于是Java类的形式，所以同样可以使用各种类注解，比如@Primary</p>
<h2 id="3-使用步骤">3、使用步骤</h2>
<h3 id="31-创建配置类">3.1、创建配置类</h3>
<ul>
<li>需要使用 <strong>@Configuration</strong> 注解标注配置类</li>
</ul>
<pre><code class="language-java">//JavaConfig.java
package spring.config;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JavaConfig {

}
</code></pre>
<h3 id="32-创建bean">3.2、创建bean</h3>
<p>StudentController类</p>
<pre><code class="language-java">//StudentController.java
package spring.controller;
import lombok.Data;
import spring.service.StudentService;

@Data
public class StudentController {
    private StudentService service;

    public StudentController() {
        System.out.println(&quot;StudentController创建&quot;);
    }
}
</code></pre>
<p>StudentService类</p>
<pre><code class="language-java">//StudentService.java
package spring.service;

public class StudentService {
    public StudentService() {
        System.out.println(&quot;StudentService创建&quot;);
    }
}

</code></pre>
<h4 id="创建bean">创建bean</h4>
<ul>
<li>使用@Bean注解标注方法，IOC容器管理方法返回的对象（与XML配置中的<bean>标签作用相同）</li>
<li>bean id为方法名</li>
</ul>
<pre><code class="language-java">//JavaConfig.java
package spring;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import spring.controller.StudentController;
import spring.service.StudentService;

@Configuration
public class JavaConfig {
    //此处创建service、controller两个bean
    @Bean
    public StudentService service() {
        StudentService service = new StudentService();
        return service;
    }

    @Bean
    public StudentController controller() {
        StudentController controller = new StudentController();
        return controller;
    }
}
</code></pre>
<h4 id="测试">测试</h4>
<p>测试类</p>
<pre><code class="language-java">//ApplicationContext.java
package spring;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.AbstractApplicationContext;
import spring.config.JavaConfig;
import spring.controller.StudentController;
import java.util.Arrays;

public class ApplicationContext {
    public static void main(String[] args) {
        AbstractApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class);
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        Arrays.stream(beanDefinitionNames).forEach(e -&gt; System.out.println(e));
    }
}
</code></pre>
<p>测试结果<br>
| 打印IOC容器中所有的bean<br>
<img src="https://cdn.jsdelivr.net/gh/midasism/cloud-img@main/img/JavaConfig.png" alt="" loading="lazy"><br>
观察到两个bean创建成功</p>
<h3 id="33-设置对象依赖">3.3、设置对象依赖</h3>
<ul>
<li>设置对象依赖时，将依赖的对象通过方法的属性传入，并在方法中通过构造方法、setter等方式注入依赖</li>
<li><strong>在查找属性对应的bean时，先按属性名查找，找不到再按属性类型查找</strong></li>
</ul>
<pre><code class="language-java">//JavaConfig.java
......
    @Bean
    public StudentController controller(StudentService service) {
        StudentController controller = new StudentController();
        controller.setService(service);
        return controller;
    }
</code></pre>
<h4 id="测试-2">测试</h4>
<p>测试结果<br>
| 打印controller<br>
<img src="https://cdn.jsdelivr.net/gh/midasism/cloud-img@main/img/JavaConfig-02.png" alt="" loading="lazy"><br>
观察到属性注入成功</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于注解配置Bean]]></title>
        <id>https://midasism.github.io/post/ji-yu-zhu-jie-chu-shi-hua-ioc-rong-qi/</id>
        <link href="https://midasism.github.io/post/ji-yu-zhu-jie-chu-shi-hua-ioc-rong-qi/">
        </link>
        <updated>2021-01-27T08:52:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-环境准备">一、环境准备</h3>
<p>Spring配置文件 <strong>applicationContext.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;!-- 开启自动扫描 --&gt;
    &lt;context:component-scan base-package=&quot;待扫描的包&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="二-相关注解">二、相关注解</h3>
<ol>
<li>@Repository：标记数据访问层（dao）</li>
<li>@Controller：标记控制器层（controller）</li>
<li>@Service：标记业务层（service）</li>
<li>@Component：标记通用组件</li>
</ol>
<h4 id="要点">要点</h4>
<ul>
<li>如果使用默认注解，则类对应的bean的id为开头字母小写的类名</li>
<li>如果想要自定义bean的id，则对注解的value属性赋值即可</li>
</ul>
<pre><code class="language-java">//无参 bean id为student
@Controller()
public class Student {
    private String name;
    private String id;
}

//bean id为 s1
//@Controller(&quot;s1&quot;)
@Controller(value = &quot;s1&quot;)
public class Student {
    private String name;
    private String id;
}
</code></pre>
<ul>
<li>在类上使用以上四个注解后，Spring会自动创建相应的BeanDefinition对象，并注册到ApplicationContext中</li>
<li>可以创建自定义注解，然后在注解上标注@Component，该自定义注解就具有了@Component的功能</li>
<li>以上4个注解功能相同，只是作用位置不同，增强可读性</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实现一个极简IOC容器]]></title>
        <id>https://midasism.github.io/post/ioc-demo/</id>
        <link href="https://midasism.github.io/post/ioc-demo/">
        </link>
        <updated>2021-01-27T02:03:34.000Z</updated>
        <content type="html"><![CDATA[<p>| 本文通过xml解析技术和反射技术手动实现Spring ioc容器通过xml配置文件初始化bean的过程，仅实现getBean方法</p>
<h3 id="1-环境准备">1、环境准备</h3>
<p>1、创建一个maven项目<br>
2、pom.xml中引入<strong>dom4j</strong>、<strong>jaxen</strong>、lombok依赖</p>
<p><strong>dom4j： xml解析组件</strong><br>
<strong>jaxen：Xpath表达式解析器</strong><br>
lombok：用于简化代码 比如setter、getter、构造器等等</p>
<pre><code class="language-xml">&lt;!--dom4j--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;dom4j&lt;/groupId&gt;
    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- jaxen--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jaxen&lt;/groupId&gt;
    &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- lombok--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="2-实现过程">2、实现过程</h3>
<p>1、实体类：Student<br>
| 此处在setter方法中打印语句，便于观察最终结果来印证ioc容器注入属性的方式</p>
<pre><code class="language-java">package com.ioc.entity;
import lombok.*;
@Getter
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Student {
    private String name;
    private String id;
    private String sex;

    public void setName(String name) {
        System.out.println(&quot;IOC容器通过setter方法注入name属性：&quot; + name);
        this.name = name;
    }

    public void setId(String id) {
        System.out.println(&quot;IOC容器通过setter方法注入id属性：&quot; + id);
        this.id = id;
    }

    public void setSex(String sex) {
        System.out.println(&quot;IOC容器通过setter方法注入sex属性：&quot; + sex);
        this.sex = sex;
    }
}
</code></pre>
<p>2、xml配置文件：applicationContext.xml<br>
| 配置文件结构和spring保持一致</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans&gt;
    &lt;bean id=&quot;s1&quot; class=&quot;com.ioc.entity.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;1928722031&quot;/&gt;
        &lt;property name=&quot;sex&quot; value=&quot;男&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>3、ApplicationContext抽象类</p>
<pre><code class="language-java">public interface ApplicationContext {
    public Object getBean(String beanId);
}
</code></pre>
<p>4、<strong>ClassPathXmlApplicationContext</strong>：Spring context实现类</p>
<pre><code class="language-java">package com.ioc.context;
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;
import java.io.File;
import java.lang.reflect.Method;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext {
    //使用Map集合
    Map&lt;String, Object&gt; iocContainer = new HashMap&lt;&gt;();

    public ClassPathXmlApplicationContext() {
        try {
            //获取配置文件的路径
            String filepath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath();
            //将路径用UTF-8解码，防止中文路径乱码
            filepath = new URLDecoder().decode(filepath, &quot;UTF-8&quot;);
            //用于解析XML文件
            SAXReader reader = new SAXReader();
            //将xml文件解析成对象 便于操作
            Document document = reader.read(new File(filepath));
            //使用Xpath表达式选择所有bean元素 每个bean元素对应一个对象
            List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;);
            for (Node e : beans) {
                //将bean节点强制转化为Element 很关键
                Element element = (Element) e;
                //获取bean标签的属性值：id class
                String id = element.attributeValue(&quot;id&quot;);
                String eClass = element.attributeValue(&quot;class&quot;);
                //获取class属性代表的类的Class对象
                Class c = Class.forName(eClass);
                //利用反射 通过空构造器实例化bean
                //注：Class对象.newInstance()已被废弃
                Object o = c.getDeclaredConstructor().newInstance();
                //使用Xpath表达式选择bean元素的所有属性值 property节点
                //每个property节点代表对象的一个属性
                List&lt;Node&gt; propertys = element.selectNodes(&quot;property&quot;);
                for (Node p : propertys) {
                    Element property = (Element) p;
                    //获取property标签的属性值：name value
                    String name = property.attributeValue(&quot;name&quot;);
                    String value = property.attributeValue(&quot;value&quot;);
                    //此处采用字符串拼接构建属性对应的setter方法名
                    String setMethodName = &quot;set&quot; + name.substring(0, 1).toUpperCase() + name.substring(1);
                    //通过方法名和Class对象得到对应的Method类 便于后续反射调用
                    Method method = c.getMethod(setMethodName, String.class);
                    //通过反射 利用属性的setter方法对属性赋值
                    method.invoke(o, value);
                }
                //将创建好的bean放入IOC容器（Map）中
                iocContainer.put(id, o);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(&quot;ioc容器已初始化&quot;);
    }

    @Override
    public Object getBean(String beanId) {
        return iocContainer.get(beanId);
    }
}
</code></pre>
<p>5、测试类：Application</p>
<pre><code class="language-java">package com.ioc.context;
import com.ioc.entity.Student;
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Student s1 = (Student) context.getBean(&quot;s1&quot;);
        System.out.println(s1);
    }
}
</code></pre>
<p>运行结果：<br>
<img src="https://cdn.jsdelivr.net/gh/midasism/cloud-img@main/img/Gridea-ioc-01.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue使用指南]]></title>
        <id>https://midasism.github.io/post/vue-an-zhuang-yu-pei-zhi/</id>
        <link href="https://midasism.github.io/post/vue-an-zhuang-yu-pei-zhi/">
        </link>
        <updated>2020-11-29T07:05:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-安装并配置nodejs">一. 安装并配置node.js</h1>
<h2 id="1-安装">1. 安装</h2>
<h3 id="常规安装">常规安装</h3>
<p>nodejs官网下载：https://nodejs.org/zh-cn/#home-downloadhead</p>
<h3 id="scoop">scoop</h3>
<pre><code>    scoop install nodejs
</code></pre>
<ul>
<li>测试安装：命令行中输入以下命令，如果输出相应版本号，则安装成功</li>
</ul>
<pre><code>node -v
npm -v
</code></pre>
<h2 id="2-环境配置">2. 环境配置</h2>
<h3 id="1配置npm安装的全局模块的存放目录和缓存cache的路径">（1）配置npm安装的全局模块的存放目录和缓存cache的路径</h3>
<ol>
<li>在nodejs安装的根路径下创建<mark>node_cache</mark>和<mark>node_global</mark>文件夹</li>
<li>通过命令将自定义文件夹设置为nodejs全局模块存放目录和缓存cache路径</li>
</ol>
<pre><code>npm config set prefix &quot;node_global磁盘全路径&quot;
npm config set cache &quot;node_cachel磁盘全路径&quot;
</code></pre>
<ol start="3">
<li>添加环境变量</li>
</ol>
<ul>
<li>修改用户变量Path：添加 node_global 文件夹磁盘全路径</li>
<li>新建系统变量NODE_PATH：值为 node_global 文件夹中的 node_modules 文件夹的磁盘全路径</li>
</ul>
<h3 id="2npm换源">（2）npm换源</h3>
<p>更换淘宝镜像</p>
<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>查看npm配置信息，包括prefix、cache路径和npm源等等</p>
<pre><code>npm config list
</code></pre>
<h1 id="二-安装vue及相关模块">二. 安装vue及相关模块</h1>
<h3 id="vue">vue</h3>
<pre><code>npm install vue -g
</code></pre>
<h3 id="webpack">webpack</h3>
<pre><code>npm install webpack -g
</code></pre>
<h3 id="vue-脚手架-vue-cli">vue 脚手架 vue-cli</h3>
<pre><code>npm install vue-cli -g
</code></pre>
<h1 id="三-创建vue项目">三. 创建vue项目</h1>
<h2 id="新建项目存放目录在终端中进入该目录">新建项目存放目录，在终端中进入该目录</h2>
<pre><code>cd 目录全路径
</code></pre>
<h2 id="创建vue项目并在终端中进入">创建vue项目，并在终端中进入</h2>
<pre><code>vue init webpack 项目名
cd 项目名
</code></pre>
<h2 id="安装项目依赖">安装项目依赖</h2>
<h3 id="安装vue-路由模块-vue-router-和网络请求模块-vue-resource">安装vue 路由模块 vue-router 和网络请求模块 vue-resource</h3>
<pre><code>npm install vue-router vue-resource --save
</code></pre>
<h2 id="启动项目">启动项目</h2>
<pre><code>npm run dev
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://midasism.github.io/post/hello-gridea/</id>
        <link href="https://midasism.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>