{"posts":[{"title":"Spring Test与JUnit4整合","content":" Spring Test是Spring中用于测试的模块 Spring Test对JUnit单元测试框架有良好的整合 通过Spring Test可以在JUnit单元测试时自动初始化IOC容器 1、环境准备 1.1、相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; 1.2、相关注解 @RunWith(SpringJUnit4ClassRunner.class)：使Spring接管JUnit的控制权，在测试用例执行前自动初始化IOC容器 @ContextConfiguration(locations = {})：说明要加载的xml配置文件的位置（可加载多个配置文件） 2、实战 //Test.java import org.junit.runner.RunWith; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import spring.service.StudentService; import javax.annotation.Resource; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = {&quot;classpath:applicationContext.xml&quot;}) public class Test { @Resource private StudentService service; @org.junit.Test public void testService() { service.test(); } } ","link":"https://midasism.github.io/post/dai-wan-cheng-spring-yu-junit4-zheng-he/"},{"title":"Java Config 配置Bean","content":"1、概述 1.1、由来 Spring IOC中有个重要的概念——Bean，Bean即对象，我们通过配置Bean让IOC容器管理Bean，而最常用的方式就是通过XML文件来配置，但通过XML文件来配置比较繁琐，数量较多的时候会使项目变得复杂，而且使用XML配置没有编译时的类型安全检查 所以在Spring4以后，Spring推荐使用Java Config代替XML文件来配置Bean Java Config就是使用注解，通过java类来描述Bean配置的组件 Java Config结合了XML的解耦和JAVA编译时检查的优点，可以看成是一个XML文件，只不过是由Java编写的 1.2、优缺点 1.2.1、优点 摒弃xml配置文件，使用Java类管理对象和依赖 注解配置相对分散，使用Java Config可以集中管理配置 可以在编译时进行依赖检查，不容易出错 1.2.2、缺点 与xml配置文件相比，可维护性差 2、相关注解 @Configuration：描述类，用于标记Java Config配置类 @Bean：描述方法，IOC容器会管理被标记方法返回的对象（bean id默认为方法名） @ComponentScan：描述类，扫描指定类中的注解配置（作用与xml配置中的context:component-scan标签相同） @ImportResource：描述类，加载静态文件，可使用@Value注解获取 | 由于是Java类的形式，所以同样可以使用各种类注解，比如@Primary 3、使用步骤 3.1、创建配置类 需要使用 @Configuration 注解标注配置类 //JavaConfig.java package spring.config; import org.springframework.context.annotation.Configuration; @Configuration public class JavaConfig { } 3.2、创建bean StudentController类 //StudentController.java package spring.controller; import lombok.Data; import spring.service.StudentService; @Data public class StudentController { private StudentService service; public StudentController() { System.out.println(&quot;StudentController创建&quot;); } } StudentService类 //StudentService.java package spring.service; public class StudentService { public StudentService() { System.out.println(&quot;StudentService创建&quot;); } } 创建bean 使用@Bean注解标注方法，IOC容器管理方法返回的对象（与XML配置中的标签作用相同） bean id为方法名 //JavaConfig.java package spring; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import spring.controller.StudentController; import spring.service.StudentService; @Configuration public class JavaConfig { //此处创建service、controller两个bean @Bean public StudentService service() { StudentService service = new StudentService(); return service; } @Bean public StudentController controller() { StudentController controller = new StudentController(); return controller; } } 测试 测试类 //ApplicationContext.java package spring; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.support.AbstractApplicationContext; import spring.config.JavaConfig; import spring.controller.StudentController; import java.util.Arrays; public class ApplicationContext { public static void main(String[] args) { AbstractApplicationContext context = new AnnotationConfigApplicationContext(JavaConfig.class); String[] beanDefinitionNames = context.getBeanDefinitionNames(); Arrays.stream(beanDefinitionNames).forEach(e -&gt; System.out.println(e)); } } 测试结果 | 打印IOC容器中所有的bean 观察到两个bean创建成功 3.3、设置对象依赖 设置对象依赖时，将依赖的对象通过方法的属性传入，并在方法中通过构造方法、setter等方式注入依赖 在查找属性对应的bean时，先按属性名查找，找不到再按属性类型查找 //JavaConfig.java ...... @Bean public StudentController controller(StudentService service) { StudentController controller = new StudentController(); controller.setService(service); return controller; } 测试 测试结果 | 打印controller 观察到属性注入成功 ","link":"https://midasism.github.io/post/dai-wan-cheng-java-config/"},{"title":"基于注解配置Bean","content":"一、环境准备 Spring配置文件 applicationContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 开启自动扫描 --&gt; &lt;context:component-scan base-package=&quot;待扫描的包&quot;/&gt; &lt;/beans&gt; 二、相关注解 @Repository：标记数据访问层（dao） @Controller：标记控制器层（controller） @Service：标记业务层（service） @Component：标记通用组件 要点 如果使用默认注解，则类对应的bean的id为开头字母小写的类名 如果想要自定义bean的id，则对注解的value属性赋值即可 //无参 bean id为student @Controller() public class Student { private String name; private String id; } //bean id为 s1 //@Controller(&quot;s1&quot;) @Controller(value = &quot;s1&quot;) public class Student { private String name; private String id; } 在类上使用以上四个注解后，Spring会自动创建相应的BeanDefinition对象，并注册到ApplicationContext中 可以创建自定义注解，然后在注解上标注@Component，该自定义注解就具有了@Component的功能 以上4个注解功能相同，只是作用位置不同，增强可读性 ","link":"https://midasism.github.io/post/ji-yu-zhu-jie-chu-shi-hua-ioc-rong-qi/"},{"title":"实现一个极简IOC容器","content":"| 本文通过xml解析技术和反射技术手动实现Spring ioc容器通过xml配置文件初始化bean的过程，仅实现getBean方法 1、环境准备 1、创建一个maven项目 2、pom.xml中引入dom4j、jaxen、lombok依赖 dom4j： xml解析组件 jaxen：Xpath表达式解析器 lombok：用于简化代码 比如setter、getter、构造器等等 &lt;!--dom4j--&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jaxen--&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 2、实现过程 1、实体类：Student | 此处在setter方法中打印语句，便于观察最终结果来印证ioc容器注入属性的方式 package com.ioc.entity; import lombok.*; @Getter @ToString @NoArgsConstructor @AllArgsConstructor public class Student { private String name; private String id; private String sex; public void setName(String name) { System.out.println(&quot;IOC容器通过setter方法注入name属性：&quot; + name); this.name = name; } public void setId(String id) { System.out.println(&quot;IOC容器通过setter方法注入id属性：&quot; + id); this.id = id; } public void setSex(String sex) { System.out.println(&quot;IOC容器通过setter方法注入sex属性：&quot; + sex); this.sex = sex; } } 2、xml配置文件：applicationContext.xml | 配置文件结构和spring保持一致 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans&gt; &lt;bean id=&quot;s1&quot; class=&quot;com.ioc.entity.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;id&quot; value=&quot;1928722031&quot;/&gt; &lt;property name=&quot;sex&quot; value=&quot;男&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 3、ApplicationContext抽象类 public interface ApplicationContext { public Object getBean(String beanId); } 4、ClassPathXmlApplicationContext：Spring context实现类 package com.ioc.context; import org.dom4j.Document; import org.dom4j.Element; import org.dom4j.Node; import org.dom4j.io.SAXReader; import java.io.File; import java.lang.reflect.Method; import java.net.URLDecoder; import java.util.HashMap; import java.util.List; import java.util.Map; public class ClassPathXmlApplicationContext implements ApplicationContext { //使用Map集合 Map&lt;String, Object&gt; iocContainer = new HashMap&lt;&gt;(); public ClassPathXmlApplicationContext() { try { //获取配置文件的路径 String filepath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath(); //将路径用UTF-8解码，防止中文路径乱码 filepath = new URLDecoder().decode(filepath, &quot;UTF-8&quot;); //用于解析XML文件 SAXReader reader = new SAXReader(); //将xml文件解析成对象 便于操作 Document document = reader.read(new File(filepath)); //使用Xpath表达式选择所有bean元素 每个bean元素对应一个对象 List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;); for (Node e : beans) { //将bean节点强制转化为Element 很关键 Element element = (Element) e; //获取bean标签的属性值：id class String id = element.attributeValue(&quot;id&quot;); String eClass = element.attributeValue(&quot;class&quot;); //获取class属性代表的类的Class对象 Class c = Class.forName(eClass); //利用反射 通过空构造器实例化bean //注：Class对象.newInstance()已被废弃 Object o = c.getDeclaredConstructor().newInstance(); //使用Xpath表达式选择bean元素的所有属性值 property节点 //每个property节点代表对象的一个属性 List&lt;Node&gt; propertys = element.selectNodes(&quot;property&quot;); for (Node p : propertys) { Element property = (Element) p; //获取property标签的属性值：name value String name = property.attributeValue(&quot;name&quot;); String value = property.attributeValue(&quot;value&quot;); //此处采用字符串拼接构建属性对应的setter方法名 String setMethodName = &quot;set&quot; + name.substring(0, 1).toUpperCase() + name.substring(1); //通过方法名和Class对象得到对应的Method类 便于后续反射调用 Method method = c.getMethod(setMethodName, String.class); //通过反射 利用属性的setter方法对属性赋值 method.invoke(o, value); } //将创建好的bean放入IOC容器（Map）中 iocContainer.put(id, o); } } catch (Exception e) { e.printStackTrace(); } System.out.println(&quot;ioc容器已初始化&quot;); } @Override public Object getBean(String beanId) { return iocContainer.get(beanId); } } 5、测试类：Application package com.ioc.context; import com.ioc.entity.Student; public class Application { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(); Student s1 = (Student) context.getBean(&quot;s1&quot;); System.out.println(s1); } } 运行结果： ","link":"https://midasism.github.io/post/ioc-demo/"},{"title":"Vue使用指南","content":"一. 安装并配置node.js 1. 安装 常规安装 nodejs官网下载：https://nodejs.org/zh-cn/#home-downloadhead scoop scoop install nodejs 测试安装：命令行中输入以下命令，如果输出相应版本号，则安装成功 node -v npm -v 2. 环境配置 （1）配置npm安装的全局模块的存放目录和缓存cache的路径 在nodejs安装的根路径下创建node_cache和node_global文件夹 通过命令将自定义文件夹设置为nodejs全局模块存放目录和缓存cache路径 npm config set prefix &quot;node_global磁盘全路径&quot; npm config set cache &quot;node_cachel磁盘全路径&quot; 添加环境变量 修改用户变量Path：添加 node_global 文件夹磁盘全路径 新建系统变量NODE_PATH：值为 node_global 文件夹中的 node_modules 文件夹的磁盘全路径 （2）npm换源 更换淘宝镜像 npm config set registry https://registry.npm.taobao.org 查看npm配置信息，包括prefix、cache路径和npm源等等 npm config list 二. 安装vue及相关模块 vue npm install vue -g webpack npm install webpack -g vue 脚手架 vue-cli npm install vue-cli -g 三. 创建vue项目 新建项目存放目录，在终端中进入该目录 cd 目录全路径 创建vue项目，并在终端中进入 vue init webpack 项目名 cd 项目名 安装项目依赖 安装vue 路由模块 vue-router 和网络请求模块 vue-resource npm install vue-router vue-resource --save 启动项目 npm run dev ","link":"https://midasism.github.io/post/vue-an-zhuang-yu-pei-zhi/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://midasism.github.io/post/hello-gridea/"}]}